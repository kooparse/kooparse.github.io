<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="image" content="https:&#x2F;&#x2F;kooparse.com/thumbnail.jpg">

    <meta name="twitter:site" content="@kooparse">
    <meta name="twitter:creator" content="@kooparse">
    <meta name="twitter:image" content="https:&#x2F;&#x2F;kooparse.com/thumbnail.jpg">
    <meta name="twitter:card" content="summary_large_image">

    <meta name="og:type" content="website">
    <meta name="og:site_name" content="Alex&#x27;s thinking box">
    <meta name="og:image" content="https:&#x2F;&#x2F;kooparse.com/thumbnail.jpg">

    <link href="https:&#x2F;&#x2F;kooparse.com/favicon.png" rel="icon">
    <link href="https:&#x2F;&#x2F;kooparse.com&#x2F;hidden&#x2F;memory-arena&#x2F;" rel="canonical">

    
  <title>Memory Arena | Alex&#x27;s thinking box</title>
  <meta name="description" content="Memory management with pre-allocation.">
  <meta name="twitter:title" content="Memory Arena">
  <meta name="twitter:description" content="Memory management with pre-allocation.">
  <meta name="og:title" content="Memory Arena">
  <meta name="og:description" content="Memory management with pre-allocation.">


    <link href="https:&#x2F;&#x2F;kooparse.com/global.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=PT+Sans:400,700&display=swap" rel="stylesheet">
  </head>

  <body>
    <div class="navbar__container">
      <div class="navbar__wrapper">
        <div class="navbar__item">
          <a href="/" id="writing">
            <div class="navbar__item">Writing</div>
          </a>
        </div>
        <div class="navbar__item">
          <a href="/about" id="about">
            <div class="navbar__item">About</div>
          </a>
        </div>
      </div>

      <div class ="navbar__night_switcher" id="night-switcher">
        <span id="switcher-icon" style="font-size: 22px;">
        </span>
      </div>
    </div>

    
<div class="main__container">
  <div class="post__spacer">
    <div class="posts__header">
      <h3 class="post__title">
        Memory Arena
      </h3>
    </div>
    <div class="post__date">
      October 31, 2019
    </div>
    <div class="post__separator"></div>

      <div class="post__text" />
        <p>For my game, I decided to store almost every entity in a big chunk of memory allocated only once when the program boot. I am using this technique for three reasons. First, I want full and precise control over how memory is managed in the game, second I want better data locality in order to increase cache hits from the cpu, and finally, at runtime asking the operating system in order to allocate more memory is slow.</p>
<p>All future entities will be stored inside an already allocated array.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">pub struct Arena&lt;T: Debug&gt; {
    &#x2F;&#x2F; All entity are stored inside this vector.
    data: Vec&lt;T&gt;,
    handles: Vec&lt;MemoryHandle&gt;,
    free_handles: Vec&lt;usize&gt;,
    version_count: usize,
}

&#x2F;&#x2F; Sneaky tl;dr example:
fn main() {
  &#x2F;&#x2F; Initialize an arena of f32, with a maximum size of 10mb.
  let arena = Arena::&lt;f32&gt;::size_alloc(10);

  &#x2F;&#x2F; Insert new values.
  let handle_1 = arena.insert(1.5);
  let handle_2 = arena.insert(2.5);
  let handle_3 = arena.insert(3.5);

  &#x2F;&#x2F; Display values.
  dbg!(arena.get(&amp;handle_1));
  dbg!(arena.get(&amp;handle_2));
  dbg!(arena.get(&amp;handle_3));

  &#x2F;&#x2F; Remove a value.
  arena.remove(handle_1);

  &#x2F;&#x2F; Iterate over all the values.
  &#x2F;&#x2F; So here, you won&#x27;t see the value from handle_1.
  arena.iter().for_each(|value| {
    dbg!(value);
  });
}
</code></pre>
<br/>
In Rust, we could specify the capacity of the vector when initializing it with the method `with_capacity`. Until the capacity isn’t reached, every push to the vector will be “free” (no allocation).
<p>Because I want full control over the memory consumption of my game while developping it; if the amount of memory is exceeded (capacity is reached), the program crash.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">#[test]
#[should_panic]
fn exceed_allocated_reserve() {
    &#x2F;&#x2F; Allocate 10Mb.
    let mut arena = Arena::&lt;bool&gt;::size_alloc(10);
    let mut last_handle = MemoryHandle::default();
    &#x2F;&#x2F; Push elements of 1 byte.
    for _ in 0..1000_0000 {
        last_handle = arena.insert(true);
    }

    assert_eq!(last_handle.value, 999_9999);

    &#x2F;&#x2F; Panic here.
    arena.insert(true);
}
</code></pre>
<p>I managed all stored entities with handles, and we always refer to them through their handles. Each handle store the index of his related entity it refer to. If we want to remove an entity, we only mark his handle as dirty.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">#[derive(Debug, Default, Copy, Clone)]
pub struct MemoryHandle {
  &#x2F;&#x2F; The entity index
  value: usize,
  is_dirty: bool,
  &#x2F;&#x2F; More on this later…
  version: usize,
}
</code></pre>
<p>So when we insert a new value in the arena, we get a memory handle ready to be used for getting the value.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">#[test]
fn store_new_block() {
    let mut arena = Arena::&lt;bool&gt;::size_alloc(10);
    let handle_0 = arena.insert(true);
    let handle_1 = arena.insert(true);

    assert_eq!(handle_0.value, 0);
    assert_eq!(handle_1.value, 1);
    assert_ne!(handle_0, handle_1);
}
</code></pre>
<p>Each time we want to read or mutate an entity we use the handle.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">&#x2F;&#x2F; My value is a pointer of the stored value.
let my_value = arena.get(&amp;handle);
&#x2F;&#x2F; And if we want to mutate the value…
let my_mut_value = arena.get_mut(&amp;handle);
</code></pre>
<p>As I said, when we remove an entity, we only mark his handle as dirty, but we also push the index of this dirty handle to an array. Like that, we could re-use our “dirty” handles and replace the “removed” data with a new one.</p>
<p>Example of this pooling system:</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">#[test]
fn remove_block() {
    let mut arena = Arena::&lt;bool&gt;::size_alloc(10);
    let handle_0 = arena.insert(true);
    let handle_1 = arena.insert(true);

    assert_eq!(handle_0.version, 1);
    assert_eq!(handle_1.version, 2);
    arena.remove(handle_0);
    assert_eq!(arena.handles[0].is_dirty, true);

    let handle_2 = arena.insert(false);
    assert_eq!(handle_2.version, 3);

    assert_eq!(arena.data[0], false);
}
</code></pre>
<p>Here's an illustration about how entities/handles are related to each others. Data vector is referred by Handles, red ones are dirty (free) and finally indexes of dirty handles are stored in an array.
<img src="https://kooparse.com/hidden/memory-arena/./arena.jpg" alt="Arena drawing" /></p>
<p>I am versioning every newly generated handle, and increment the version counter every time. So we can’t mess up handles. Comparing an old handle (freed since) and a new one, while both are referring to the same entity index; we won’t have any problems because the “version” isn’t the same.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">impl PartialEq for MemoryHandle {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.value == other.value &amp;&amp; self.version == other.version
    }
}

</code></pre>
<p>Also, I have a flush method, to mark all current handles as dirty, and push them into the re-use pool. It’s perfect when we want to load a new scene :)</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">#[test]
fn flush() {
    let mut arena = Arena::&lt;bool&gt;::size_alloc(10);
    let handle_0 = arena.insert(true);
    let _ = arena.insert(true);
    let _ = arena.insert(true);

    assert_eq!(*arena.get(&amp;handle_0), true);

    arena.flush();

    let should_panic = catch_unwind(|| arena.get(&amp;handle_0));
    assert_eq!(should_panic.is_err(), true);
}
</code></pre>
<p>That’s all for now! :)</p>

      </div>
      <hr class="post__end_liner" />

      <ul class="post__footer">
        <li class="post__footer_block post__prev_block">
          
        </li>

        <li class="post__footer_block post__next_block">
          
        </li>
      </ul>
    </div>
  </div>


    <script>
      window.__is_about = /about\/$/.test(window.location.href);
      window.__isNightMode = !!window.localStorage.getItem('isNightMode');

      const body = document.getElementsByTagName('body')[0];
      body.classList.add(window.__isNightMode ? 'dark' : 'light');

      const writing_nav = document.getElementById('writing');
      const about_nav = document.getElementById('about');
      const switcher_icon = document.getElementById('switcher-icon');

      if (window.__is_about) {
            writing_nav.classList.remove('active_tab');
            about_nav.classList.add('active_tab');
      } else {
          writing_nav.classList.add('active_tab');
          about_nav.classList.remove('active_tab');
      }

      document.getElementById("night-switcher")
        .addEventListener("click", () => window.__setTheme());

      switcher_icon.classList.add(window.__isNightMode 
        ? 'icon-moon-solid' 
        : 'icon-moon-regular'
      );

      window.__setTheme = function() {
          const isNightMode = window.localStorage.getItem('isNightMode')

          if (isNightMode) {
            window.localStorage.removeItem('isNightMode')
            body.classList.remove('dark');
            body.classList.add('light');

            switcher_icon.removeAttribute("class");
            switcher_icon.classList.add('icon-moon-regular')
          } else {
            window.localStorage.setItem('isNightMode', 'true')
            body.classList.remove('light');
            body.classList.add('dark');

            switcher_icon.removeAttribute("class");
            switcher_icon.classList.add('icon-moon-solid')
          }

          window.__isNightMode = !isNightMode;
      }
    </script>

    <script data-goatcounter="https://kooparse.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
  </body>

</html>
